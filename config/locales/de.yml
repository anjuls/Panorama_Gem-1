de:
# Globale Texte ohne Bezug zu erb
  additional_infos:                                         Zusätzliche Informationen
  and:                                                      und
  close:                                                    Schliessen
  content:                                                  Inhalt
  day:                                                      Tag
  error:                                                    Fehler
  first_occurrence_caption:                                 Erstes Auftreten
  first_occurrence_hint:                                    Erstes Auftreten im betrachteten Zeitraum
  from:                                                     aus
  from_until:                                               von
  generally:                                                Generell
  grouping:                                                 Gruppierung
  grouping_hint:                                            Gruppierung der Anzeige nach Attribut
  help:                                                     Hilfe
  hour:                                                     Stunde
  instance_optional_filter_hint:                            Einschränkung/Filterung auf RAC-Instance (optional)
  last_occurrence_caption:                                  Letztes Auftreten
  last_occurrence_hint:                                     Letztes Auftreten im betrachteten Zeitraum
  link_historic_sql_id_coming_soon:                         Hier erscheint gleich der Text des SQL, bitte Maus erneut über Objekt führen
  link_historic_sql_id_hint_prefix:                         Anzeige der Details des
  minute:                                                   Minute
  moeglicher:                                               möglicher
  month:                                                    Monat
  of:                                                       des
  per_execution:                                            je Execution
  second:                                                   Sekunde
  show:                                                     Anzeigen
  sorted_by:                                                Sortiert nach
  sqlid_optional_filter_hint:                               Einschränkung/Filterung auf konkrete SQL-ID (optional,  Wildcards (%,_) sind erlaubt)
  tables:                                                   Tabellen
  time_selection_start_caption:                             Start
  time_selection_start_hint:                                Start des Betrachtungszeitraumes im Format
  time_selection_end_caption:                               Ende
  time_selection_end_hint:                                  Ende des Betrachtungszeitraumes im Format
  until:                                                    bis
  week:                                                     Woche
  without:                                                  ohne

# Dialogspezifische Texte (alphabetisch)
  active_session_history_load_hint:                         Durchschn. Anzahl wartender Sessions gemittelt über Zeit zwischen erstem und letzten Auftreten

  active_session_history_duration_caption:                  Dauer
  active_session_history_duration_hint:                     Dauer in Sekunden innerhalb des Zeitraumes als Zeitabschnitt
  active_session_history_first_occurrence_caption:          Erstes Auftreten
  active_session_history_first_occurrence_hint:             Erstes Auftreten eines sample-record in Gruppierung
  active_session_history_helper_db_object_title: |-
    aus gv$Session.Row_Wait_Obj#. Wenn p2Text=object#, dann wird diese genutzt anstatt row_wait_obj#. Achtung: Kann auch Objekt der vorherigen Aktion enthalten
  active_session_history_info_hint:                         Nähere Info zu Gruppierungskriterium
  active_session_history_last_occurrence_caption:           Letztes Auftreten
  active_session_history_last_occurrence_hint:              Letztes Auftreten eines sample-record in Gruppierung

  active_session_history_list_blocking_locks_historic_total_wait_caption: Summe Anzahl Sekunden die mittelbar und unmittelbar geblockte Sessions bereits im Wartezustand warten

  active_session_history_list_groupfilter_delete_filter_hint: Refresh der Anzeige ohne diesen Filter
  active_session_history_list_groupfilter_refresh_hint:     Aktualisieren der Anzeige mit den geänderten Parametern
  active_session_history_first_occurrence_caption:          Erstes Auftreten

  active_session_history_list_blocking_locks_historic_snapshot_hint:    Zeitstempel der Aufzeichnung des Locks (gerundet auf 1 bzw. 10 Sekunden)
  active_session_history_list_blocking_locks_historic_detail_instance_hint:  Instance der geblockten Session
  active_session_history_list_session_statistic_single_record_link_sid_hint: Anzeige Active Session History der Session
  active_session_history_list_session_statistic_historic_link_hint: Anzeige der Verdichtung aus Samples der Gruppierung nach
  active_session_history_list_session_statistic_historic_grouping_header: Verdichtung nach
  active_session_history_list_session_statistic_historic_grouping_link_hint: Anzeige der unterschiedlichen

  active_session_history_list_session_statistic_historic_single_record_caption:           Einzel Snapshot-Records für
  active_session_history_list_session_statistic_historic_single_record_object_hint: |-
    Aktuell referenziertes Objekt aus gv$Session.Row_Wait_Obj#. Wenn p2Text="object#", dann wird diese genutzt anstatt row_wait_obj#. Achtung: Kann auch Objekt der vorherigen Aktion enthalten
  active_session_history_list_session_statistic_historic_single_record_plsql_hint: |-
    PL/SQL: Einstiegs- und aktuelles Objekt
  active_session_history_list_session_statistic_historic_single_record_sample_time_hint:  Zeitpunkt des Sample
  active_session_history_list_session_statistic_historic_single_record_sql_id_title:      SQL-ID des aktuellen Statements + optional SQL-ID des Top-Level-SQL

  active_session_history_list_session_statistic_historic_timeline_header: |-
    Anzahl wartende Sessions verdichtet auf %{group_seconds} Sekunden für Top-10 gruppiert nach: <b>%{groupby}</b>, Filter: %{filter}
  active_session_history_number_hint:                       (< Anzahl > wenn mehrere)
  active_session_history_samples_hint:                      Gesamt-Anzahl Sample-Records in Gruppierung
  active_session_history_samples_link_hint:                 Anzeige der einzelnen Samples der Gruppierung

  active_session_history_show_blocking_locks_submit_caption: Blocking Locks anzeigen
  active_session_history_show_blocking_locks_submit_hint:   Anzeige Historie der Blocking Locks

  active_session_history_show_session_statistics_historic_idle_hint: |-
    Idle-Waits (z.B. PX Deq Credit: send blkd) in Betrachtung berücksichtigen?
  active_session_history_show_session_statistics_historic_submit_caption:   Waits anzeigen
  active_session_history_show_session_statistics_historic_submit_hint:      Anlistung der verdichteten Session-Waits

  active_session_history_show_top_ten:                      Zeige Top 10 in Zeitleiste, verdichtet nach %{sec} Sek.
  active_session_history_show_top_ten_hint:                 Anzeige der Top 10 nach total time waited in Zeitleiste, jeweils ein Punkt im Graph für die Summe über %{sec} Sekunden
  active_session_history_total_time_waited_hint:            Summe Time waited in Sekunden (Sample-Zyklus(1/10 Sekunden) * Samples)

  application_connection_no_db_choosen:                     Keine DB ausgewählt! Bitte rechts oben DB auswählen! (Speicherung von Browser-Cookies ist erforderlich)

  application_helper_delimiter_on_pos:                      Trenner an Position
  application_helper_length_error:                          Länge des Ausdrucks
  application_helper_is_not:                                ist nich
  application_helper_range_error_day:                       Tag nicht zwischen 01 und 31
  application_helper_range_error_hour:                      Stunde nicht zwischen 00 und 23
  application_helper_range_error_minute:                    Minute nicht zwischen 00 und 59
  application_helper_range_error_month:                     Monat nicht zwischen 01 und 12
  application_helper_range_error_year:                      Jahr nicht zwischen 1000 und 2999
  application_helper_ts_invalid_format:                     Ungültiges Format des Zeitstempels
  application_helper_ts_expected:                           Erwartet wird

  ajax_helper_link_sql_id_title_prefix:                     Anzeige der Details in SGA für
  ajax_helper_link_wait_params_hint:                        Anzeige der Details zu den Wait-Parametern des Events

  dba_history_list_segment_stat_historic_sum_link_sql_hint: Anzeige der SQL-Statements des Zeitraums aus DBA_Hist_SQLStat mit Nutzung des Objekts im Explain Plan
  dba_history_list_segment_stat_historic_sum_link_wait_hint: Detaillierung der angefallenen Wartezeiten des Objektes
  dba_history_list_segment_stat_historic_sum_sqls_hint:     Anzahl SQLs für dieses Objekt in kompletter AWR-Historie unanhängig von gewähltem Zeitraum

  dba_history_list_sql_area_historic_execs_hint:                Anzahl Ausführungen
  dba_history_list_sql_area_historic_link_column_snap_title:    Anzeige der Werte der einzelnen AWR-Snapshots (unterhalb)

  dba_history_list_sql_detail_execution_access_hint:            Zugriffskriterium auf Objekt
  dba_history_list_sql_detail_execution_filter_hint:            Filterkriterium auf Objekt
  dba_history_list_sql_detail_execution_plan_id_hint:           ID der Operation
  dba_history_list_sql_detail_execution_plan_objectname_hint:   Name des Objekts
  dba_history_list_sql_detail_execution_plan_operation_hint:    Art des Zugriffs
  dba_history_list_sql_detail_execution_plan_order_hint:        Reihenfolge der Operation

  dba_history_list_sql_detail_historic_action_link_hint:              Detaillierung des Action-Namens
  dba_history_list_sql_detail_historic_bind_name:                     Name der Vindevariablen im Statement
  dba_history_list_sql_detail_historic_bind_pos:                      Position der Bindevariablen im Statement
  dba_history_list_sql_detail_historic_binds_caption:                 Zuletzt aufgezeichnete Bindevariablen
  dba_history_list_sql_detail_historic_complete_timeline_caption:     Komplette Zeitleiste des SQL
  dba_history_list_sql_detail_historic_complete_timeline_hint:        Anlistung der kompletten gespeicherten zeitlichen Historie des SQL
  dba_history_list_sql_detail_historic_last_plan_hash_hint:           Hash-Value des letzten Explain-Plans
  dba_history_list_sql_detail_historic_module_link_hint:              Detaillierung des Modul-Namens
  dba_history_list_sql_detail_historic_module_action_hint:            Module und Action der Session, von der Statement zuletzt geparst wurde
  dba_history_list_sql_detail_historic_plan_count_hint:               Anzahl unterschiedliche Ausführungspläne im Zeitraum
  dba_history_list_sql_detail_historic_current_sga_caption:           SQL in aktueller SGA
  dba_history_list_sql_detail_historic_current_sga_hint:              Anlistung der Daten des SQL in der aktuellen SGA der DB (wenn vorhanden)

  dba_history_list_sql_history_snapshots_caption:           Aufkommen an Daten aus DBA_Hist_SQL_Stat von für SQL-ID = '%{sql_id}' Instance = %{instance}
  dba_history_list_sql_history_snapshots_execs_hint:        Anzahl der Ausführungen des SQL im Intervall
  dba_history_list_sql_history_snapshots_first_occurrence_caption:      Erstes Auftreten
  dba_history_list_sql_history_snapshots_first_occurrence_hint:         Erstes Auftreten des SQL im Intervall
  dba_history_list_sql_history_snapshots_last_occurrence_caption:       Letztes Auftreten
  dba_history_list_sql_history_snapshots_last_occurrence_hint:          Letztes Auftreten des SQL im Intervall
  dba_history_list_sql_history_snapshots_link_sql_detail_hint:          Anzeige der Details des Statements für diesen Zeitraum aus DBA_Hist_SQLStat (unterhalb)
  dba_history_list_sql_history_snapshots_start_hint:        Beginn des betrachteten Intervalls
  dba_history_list_sql_history_snapshots_start_data_hint:   Beginn des betrachteten Intervalls, Ende = %{end_interval}

  dba_history_show_sql_area_historic_caption:                   SQL's aus DBA_Hist_SQLStat
  dba_history_show_sql_area_historic_filter_hint:               Filter-string muss in betrachteten SQL-Statements enthalten sein. Wildcards (%,_) können benutzt werden. (optional)
  dba_history_show_sql_area_historic_max_result_count_caption:  Anzahl Treffer
  dba_history_show_sql_area_historic_max_result_count_hint:     Einschränkung der Treffermenge auf max. Anzahl Zeilen (nach Sortierung)
  dba_history_show_sql_area_historic_submit_caption:            SQL anzeigen
  dba_history_show_sql_area_historic_submit_hint:               Anlistung der SQL nach Suchkriterien

  dba_history_show_sysmetric_historic_grouping_hint:        Verdichtung der Werte auf Zeitabschnitt
  dba_history_show_sysmetric_historic_header:               SysMetric-Historie aus DBA_Hist_SysMetric_History/GV$SysMetric_History oder DBA_Hist_SysMetric_Summary/GV$SysMetric_Summary
  dba_history_show_sysmetric_submit_detail_caption:         Anzeige Details
  dba_history_show_sysmetric_submit_detail_hint:            Details der SysMetric-Historie anzeigen aus DBA_Hist_SysMetric_History/GV$SysMetric_History
  dba_history_show_sysmetric_submit_summary_caption:        Anzeige Summen
  dba_history_show_sysmetric_submit_summary_hint:           Details der SysMetric-Historie anzeigen aus DBA_Hist_SysMetric_Summary/GV$SysMetric_Summary (mehr verdichtet)

  dba_list_blocking_dml_locks_link_column_blocking_object_hint: Ermitteln der zugehörigen RowID

  dba_list_dml_locks_link_column_blocking_object_hint:      Ermitteln der zugehörigen RowID

  dba_list_rowid_link_hint:                                 Zeige Felder und Werte des Primary der Tabelle

  dba_schema_list_objects_caption:                          Objekte für

  dba_schema_show_object_filter_hint:                       Filter-string muss in Objekt-name enthalten sein (wenn belegt)
  dba_schema_show_object_partition_hint:                    Einzelne Partitionen anzeigen?
  dba_schema_show_object_submit_caption:                    Objekte und Größen anzeigen
  dba_schema_show_object_submit_hint:                       Objekte mit Größen und Parametern je Tablespace und Schema anzeigen

  dba_segment_stat_caption:                                 Objekt-spezifische Statistiken aus V$Segment_Statistics
  dba_segment_stat_only_sample_change_caption:              Nur Änderungen während Sample
  dba_segment_stat_only_sample_change_hint:                 Nur Objekte anzeigen deren Daten sich zwischen den Samples änderten

  dba_segment_stat_partition_caption:                       Partitionen anzeigen
  dba_segment_stat_partition_hint:                          Objekt-Info auf Partitionsebene anzeigen
  dba_segment_stat_sample_length_hint:                      Distanz zwischen den zwei sample-snapshots in Sekunden
  dba_segment_stat_show_caption:                            Statistik anzeigen
  dba_segment_stat_show_hint:                               Anzeige der Statistik für Objekte

  dba_list_session_details_caption:                         Details zu Session

  dba_list_sessions_machine_hint:                           Name der Client-Maschine
  dba_list_sessions_client_user_hint:                       Betriebssystem-User der Client-Maschine
  dba_list_sessions_io_hint:                                Gewichteter Wert der logischen und physischen I/O der Session
  dba_list_sessions_last_active_start_hint:                 Beginn der letzten Active-Phase der Session
  dba_list_sessions_long_hint:                              Langlaufendes SQL-Statement
  dba_list_sessions_open_cursor_hint:                       Anzahl offene Cursor der Session
  dba_list_sessions_open_cursor_sql_hint:                   Anzahl unterschiedliche SQL-IDs der offenen Cursor der Session
  dba_list_sessions_pga_free_hint:                          Aktuell von Prozess alloziierter PGA-Memory der freigegeben werden kann in MB
  dba_list_sessions_pga_used_hint:                          Aktuell von Prozess genutzter PGA-Memory in MB
  dba_list_sessions_pq_hint:                                Anzahl ParallelQuery-Slave-Prozesse
  dba_list_sessions_proc_hint:                              Prozess-ID Oracle Shadow-Prozess auf DB-Server
  dba_list_sessions_process_hint:                           Prozess-ID des Client-Prozesses auf der Client-Maschine (1234 ist Dummy-Prozess-ID von JDBC-Treibern, CONNECTION_PROPERTY_THIN_VSESSION_PROCESS_DEFAULT=1234)
  dba_list_sessions_program_hint:                           Ausgeführtes Programm des Client-Prozesses auf der Client-Maschine
  dba_list_sessions_service_hint:                           Name des TNS-Service über den die Session connected ist
  dba_list_sessions_show_session_hint:                      Anzeige Details zu Session
  dba_list_sessions_temp_hint:                              Genutzter Temp-Tablespace (MB)

  dba_sga_list_sql_area_caption:                            SQL der aktuellen SGA aus %{modus}, gruppiert nach

  dba_sga_list_sql_detail_execution_plan_cr_title:          Durchschn. Anzahl Buffer gets in consistend mode (meist für Query) der Operation je Ausführung des SQL, kumulativ inlusive aller untergeordneten Operationen
  dba_sga_list_sql_detail_execution_plan_cu_title:          Durchschn. Anzahl Buffer gets in current mode (meist für Insert/Update/Delete) der Operation je Ausführung des SQL, kumulativ inlusive aller untergeordneten Operationen
  dba_sga_list_sql_detail_execution_plan_disk_reads_title:  Durchsch. Anzahl physische Disk-Reads der Operation je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_disk_writes_title: Durchsch. Anzahl physische Disk-Writes der Operation je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_elapsed_title:     Durchschn. Dauer der Operation in ms je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_rows_title:        Durchschn. Anzahl produzierte Rows der Operation je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_starts_title:      Durchschnittliche Anzahl Starts der Operation je Ausführung des SQL

  dba_sga_show_sga_components_caption:                      Anzeige der Memory-Verbraucher der SGA
  dba_sga_show_sga_components_submit_caption:               Anzeige der Memory-Komponenten
  dba_sga_show_sga_components_submit_hint:                  Anlistung der Memory-Komponenten der SGA

  dba_sga_show_sql_area_caption:                            Ressourcenintensive Statements aus
  dba_sga_show_sql_area_filter_hint:                        Filter-string muss in betrachteten SQL-Statements enthalten sein. Wildcards (%,_) können benutzt werden. (optional)
  dba_sga_show_sql_area_max_result_count_caption:           Anzahl Treffer
  dba_sga_show_sql_area_max_result_count_hint:              Einschränkung der Treffermenge auf max. Anzahl Zeilen (nach Sortierung)
  dba_sga_show_sql_area_sort_last_active_hint:              Sortiert nach Zeitpunkt der letzten Ausführung des SQL
  dba_sga_show_sql_area_sort_memory_hint:                   Sortiert nach Größe des allokierten Speichers in der SGA
  dba_sga_show_sql_area_submit_caption:                     SQL anzeigen
  dba_sga_show_sql_area_submit_hint:                        Anlistung der SQL nach Suchkriterien

  dba_show_locks_caption:                                   Aktuell Locks verschiedener Typen anlisten
  dba_show_locks_all_locks_caption:                         Alle Locks
  dba_show_locks_all_locks_hint:                            Alle Locks anlisten? Sonst AE- und PS-Locks unterdrücken.
  dba_show_locks_max_result_size_caption:                   max. anzuzeigen
  dba_show_locks_max_result_size_hint:                      Limitierung auf maximale Anzahl Zeilen des Resultates der Abfrage
  dba_show_locks_submit_dml_caption:                        DML-Locks komplett
  dba_show_locks_submit_dml_hint:                           Alle DML-Locks (Data Manipulation) anzeigen
  dba_show_locks_submit_blocking_hint:                      Blockierende DML-Locks (Data Manipulation) anzeigen
  dba_show_locks_submit_ddl_hint:                           DDL-Locks (Data-Definition) anzeigen

  dba_show_sessions_caption:                                Anzeige Sessions
  dba_show_sessions_filter_hint: |-
    Optionaler LIKE-Filter für  Client/Shadow-Process auf: Session-ID, Process-ID, Username, Client-Info, Module, Action, Maschine, Programm
  dba_show_sessions_only_active_caption:                    Nur Aktive
  dba_show_sessions_only_active_hint:                       Nur aktive Sessions anzeigen
  dba_show_sessions_only_db_link_caption:                   Nur DB-Link
  dba_show_sessions_only_db_link_hint:                      Nur Sessions anzeigen, die über DB-Link angemeldet sind
  dba_show_sessions_only_user_caption:                      Nur User
  dba_show_sessions_only_user_hint:                         Nur User-Sessions anzeigen
  dba_show_sessions_pq_hint:                                Parallel-Query Sessions anzeigen
  dba_show_sessions_submit_caption:                         Sessions anzeigen
  dba_show_sessions_submit_hint:                            Anzeige der DB-Sessions nach gegebenen Filtern

  dragnet_exec_dragnet_sql_selection_raise:                 Bitte erst konkrete Selektion auswählen

  dragnet_helper_group_cascading_views:                     Views mit kaskadierenden Abhängigkeiten (mehrstufige Hierarchie)
  dragnet_helper_group_conclusion_application:              Rückschlüsse auf Applikationsverhalten
  dragnet_helper_group_cursor_redundancies:                 Redundante Cursoren / Nutzung Bindevariablen
  dragnet_helper_group_index_partitioning:                  Empfehlungen für Index-Partitionierung
  dragnet_helper_group_logwriter_redo:                      LogWriter-Belastung / Redolog-Aufkommen
  dragnet_helper_group_optimizable_full_scans:              Optimierbare Full-Scan Operationen
  dragnet_helper_group_optimal_index_storage:               Sicherstellen optimaler Storage-Parameter für Indizes
  dragnet_helper_group_pl_sql_usage:                        Hinweise zur Nutzung von PL/SQL
  dragnet_helper_group_potential_db_structures:             Potential in DB-Strukturen
  dragnet_helper_group_problems_with_parallel_query:        Eventuelle Probleme mit Parallel Query
  dragnet_helper_group_tuning_sga_pga:                      Tuning bzw. Entlastung von SGA/PGA-Strukturen
  dragnet_helper_group_unnecessary_executions:              Eventuell unnötige Ausührungen von SQL-Statements
  dragnet_helper_group_unnecessary_high_execution_frequency:  Eventuell unnötig hohe Frequenz von Executes/Fetches von SQL-Statements
  dragnet_helper_group_unnecessary_indexes:                 Identifikation eventuell unnötiger Indizes
  dragnet_helper_group_unused_tables:                       Ermittlung ungenutzter tabellen oder Spalten
  dragnet_helper_group_wrong_execution_plan:                Ermittlung von SQL-Statements mit suboptimalem Ausführungsplan

  dragnet_helper_param_executions_hint:                     Minimale Anzahl Executions im Zeitraum für Aufnahme in Selektion
  dragnet_helper_param_executions_name:                     Minmale Anzahl Executions

  dragnet_helper_param_history_backward_hint:               Anzahl Tage rückwärts von jetzt für Auswertung der Historie
  dragnet_helper_param_history_backward_name:               Betrachtung der Historie rückwärts in Tagen

  dragnet_helper_param_minimal_rows_hint:                   Minimale Anzahl Rows in Table für Aufnahme in Selektion
  dragnet_helper_param_minimal_rows_name:                   Minimale Anzahl Rows in Table

  dragnet_helper_param_minimal_ela_per_exec_hint:           Minimale elapsed time per execution in Sekunden für Aufnahme in Selektion
  dragnet_helper_param_minimal_ela_per_exec_name:           Minimale elapsed time/Execution (Sec.)

  dragnet_helper_1_desc: |-
    Sicherstellen, dass Indizes mit PCTFree >= 10 gefahren werden (Minimum als Erfahrungswert).
    Mit PCTFree < 10 (insbesondere = 0) sind Probleme mit automatischer Ausbalancierung zu erwarten, insbesondere beim Insert der Daten in vorsortierter Folge
  dragnet_helper_1_name:                                    Sicherstellen Index PCTFree >= 10
  dragnet_helper_1_param_1_name:                            Schwellwert für PctFree Index
  dragnet_helper_1_param_1_hint:                            Selektion von Indizes, die diesen Wert für PctFree unterschreiten
  dragnet_helper_1_param_2_name:                            Schwellwert für PctFree Index-Partition
  dragnet_helper_1_param_2_hint:                            Selection von Index-Partitions, die diesen Wert unterschreiten für PctFree
  dragnet_helper_1_param_3_name:                            Minimale Anzahl Rows
  dragnet_helper_1_param_3_hint:                            Minimale Anzahl Rows im Index für Aufnahme in Selektion

  dragnet_helper_2_desc: |-
    Index-Kompression (COMPRESS) bringt sinnvolle Ergebnisse durch Reduktion der physischen Größe für OLTP-Indizes mit geringer Selektivität.
    Bei geringer Selektivität der Indizes ist Reduzierung der Größe durch Komprimierung um 1/4 bis 1/3 möglich.
  dragnet_helper_2_name:                                    Test auf empfehlenswerte Index-Komprimierung
  dragnet_helper_2_param_1_hint:                            Mindestanzahl Zeilen des Index je DISTINCT Key
  dragnet_helper_2_param_2_name:                            Schwellwert für Index-Größe (MB)
  dragnet_helper_2_param_2_hint:                            Selection von Indizes, deren Größe in MB diesen Wert überschreitet

  dragnet_helper_3_desc: |-
    Index-Kompression (COMPRESS) bringt sinnvolle Ergebnisse durch Reduktion der physischen Größe für OLTP-Indizes mit geringer Selektivität.
    Bei geringer Selektivität der Indizes ist Reduzierung der Größe durch Komprimierung um 1/4 bis 1/3 möglich.
    Bei komprimiertem Index sollten alle Verweise auf Data-Blocks eines Keys in einen Leaf-Block passen
  dragnet_helper_3_name:                                    Empfehlungen für Index-Komnprimierung, Test auf Leaf-Blocks
  dragnet_helper_3_param_1_hint:                            Mindestanzahl Leaf-Blocks / Key

  dragnet_helper_4_desc: |-
    IOT-Struktur für Tabellen lohnt sich, wenn folgende positiven und negativem Kriterien zum positiven überwiegen:
    Positiv: Einsparung von Plattenplatz durch Wegfall der Speicherung der Inhalte als Tabelle
    Positiv: Wegfall des 'Table-Access by RowID' bei Zugriff auf Tabelle über Index, da Index bereits alle Daten enthält
    Negativ: Vergrößerung von secondLevel-Indizes wegen redundanter Speicherung der PKey-Values in jedem sekundären Index
    Negativ: Vergrößerung des Primary Keys durch Speicherung der Nicht-PKey-Felder
  dragnet_helper_4_name:                                    Redundanzfreie Ablage von Daten im Primary Key-Index (Umwandlung in Index-organized Tables)
  dragnet_helper_4_param_1_hint:                            Mindestanzahl Rows des Index

  dragnet_helper_5_desc: |-
    Absichern von Spalten mit Foreign-Key-Referenzen durch Index kann notwendig sein für:
    - Delete-Performance der referenzierten Tabelle (verhindern FullTable-Scan)
    - Verhindern Lock-Propagierung (shared Lock auf Index statt auf Table)
  dragnet_helper_5_name:                                    Absicherung von Foreign Key-Beziehungen durch Indizes (Ermittlung evtl. fehlender Indizes)
  dragnet_helper_5_param_1_hint:                            Mindestanzahl Rows der referenzierten Tabelle
  dragnet_helper_5_param_1_name:                            Min. Anzahl Rows referenzierte Tabelle

  dragnet_helper_6_name:                                    Absicherung von Foreign Key-Beziehungen durch Indizes (Ermitteln möglicherweise unnötiger Indizes)
  dragnet_helper_6_desc: |-
    Die Absicherung eines Foreign Key durch Index ist evtl. nicht nötig, wenn:
    - auf der referenzierten Tabelle nicht physisch gelöscht wird oder
    - bei Löschung der FullScan auf den referenzierenden Tabellen toleriert werden kann und
    - durch Fehlern der Indizes mögliche Shared-Lock-Probleme auf der referenzierten Tabelle kein Problem darstellen
    Inbesondere bei Referenzen sehr großer Tabellen auf sehr kleine Stammtabellen ist der Aufwand für die Indizierung oft nicht gerechtfertigt.
    Auf Grund der geringen Selektivität dieser Indizes sind sie außer der Absicherung des Foreign Keys kaum zur Zugriffsoptimierung zu gebrauchen.
  dragnet_helper_6_param_1_hint:                            Max. Anzahl Rows referenzierte Tabelle
  dragnet_helper_6_param_1_name:                            Max. Anzahl Rows referenzierte Tabelle
  dragnet_helper_6_param_2_hint:                            Mindestanzahl Rows der referenzierenden Tabelle
  dragnet_helper_6_param_2_name:                            Min. Anzahl Rows referenzierende Tabelle
  dragnet_helper_6_param_3_hint:                            Max. Anzahl referenzierende Tabellen (bei groesserer Anzahl FullScan-Problem bei Delete auf Master)
  dragnet_helper_6_param_3_name:                            Max. Anzahl referenzierende Tabellen

  dragnet_helper_7_name:                                    Identifikation nicht für Zugriffe oder Absicherung von Eindeutigkeit benutzte Indizes
  dragnet_helper_7_desc: |-
    Selektion von Non-Unique Indizes, für die keine Nutzung in SQL-Statements erkennbar ist.
    Für Indizes, die nicht für Absicherung von Eindeutigkeit und nicht für Datenzugriff genutzt werden, kann die Frage nach der Daseinsberechtigung des Index gestellt werden.
    Die Berechtigung kann trotzdem zur Absicherung von Foreign Keys gegeben sein, auch wenn im Betrachtungszeitraum keine Zugriffe stattfanden.
    Letztlich Sicherheit über Nutzung gibt 'ALTER INDEX ... MONITORING USAGE' sowie Kontrolle über V$OBJECT_USAGE.
    Weitere Informationen zur Nutzung bringt Anzeige 'Segment statistics historisch' und Analyse der ActiveSessionHistory über Spalte 'Time waited'.

  dragnet_helper_8_name:                                    Identifikation von Indizes mit doppelt indizierte Spalten
  dragnet_helper_8_desc: |-
    Mehrfach indizierte Spalten bringen nur Nutzen im Such-Zugriff, wenn weitere Felder die Selektivität des Index verfeinern.
    Die Indizierung einer Spalte, die bereits durch einen mehrspaltigen Index indiziert ist, ist oftmals überflüssig, z.B. zur Absicherung von Foreign Keys.
    Alternativ kann mehrfache Indizierung der selben Spalte in verschiedenen Composite-Indizes jedoch der Optimierung von Join-Beziehungen dienen bzw. der vollständigen Abdeckung eines Zugriffs ohne Table-Access
  dragnet_helper_8_param_1_hint:                            Minimale Anzahl Rows des Index für Berücksichtigung in Auswertung
  dragnet_helper_8_param_1_name:                            Minmale Anzahl Rows des Index

  dragnet_helper_9_name:                                    Erkennung nicht genutzter Indizes durch System-Monitoring
  dragnet_helper_9_desc: |-
    Die DB Protokolliert die Nutzung (Zugriff) von Indizes die vorab durch 'ALTER INDEX ... MONITORING USAGE' deklariert wurden.
    Das Ergebnis der Nutzungsprotokollierung ist je Schema in Tabelle v$Object_Usage einsehbar.
    Schemaübergreifend ist die Nutzung mit diese Selektion sichtbar.
    Achtung: Auch die Ausführung von GATHER_INDEX_STATS zählt als Nutzung, selbts wenn der Index nie durch andere Selects genutzt wurde.

    Weitere Informationen zur Nutzung bringt Anzeige 'Segment statistics historisch' und Analyse der ActiveSessionHistory über Spalte 'Time waited'.
  dragnet_helper_9_param_1_hint:                            Anzahl Tage, die der Start_Monitoring-Zeitstempel ungenutzter Indizes alt sein muss
  dragnet_helper_9_param_1_name:                            Tage rückwärts ohne Nutzung
  dragnet_helper_9_param_2_hint:                            Minimale Anzahl Rows des Index für Aufnahme in Selektion
  dragnet_helper_9_param_2_name:                            Minimale Anzahl Rows des Index

  dragnet_helper_10_name:                                   Identifikation von Indizes mit unnötigen Spalten mit geringer Selektivität
  dragnet_helper_10_desc: |-
    Bei MultiColumn-Indizes mit hoher Selektivität einzelner Spalten wird durch weitere Spalten im Index die Selektivität nicht weiter signifikant verbessert
    Sinn machen zusätzliche Spalten mit niedriger Selektivität nur wenn sie:
    - Die Selektivität des gesamten Index wesentlich verbessern
    - Den Zugriff auf Spalten der Tabelle allein durch Index ohne weiteren table access ermöglichen
    Ist der o.g. Sinn nicht gegeben, können zusätzliche Spalten mit niedriger Selektivität ersatzlos entfallen.
    Fur Eliminierung von 'table access by rowid' genutzte Indizes (alle Daten aus Index) sind in Selektion nicht enthalten.
  dragnet_helper_10_param_1_hint:                            Anzahl DISTINCT-Werte des Index-Feldes mit der größten Selektivität ist > 1/x der Anzahl Rows des Index
  dragnet_helper_10_param_1_name:                            Größte Selektivität eines Feldes des Index > 1/x der Anzahl Rows
  dragnet_helper_10_param_2_hint:                            Minimale Anzahl Rows des Index für Aufnahme in Selektion
  dragnet_helper_10_param_2_name:                            Minimale Anzahl Rows des Index

  dragnet_helper_11_name:                                   Local-Partitionierung für NonUnique-Indizes
  dragnet_helper_11_desc: |-
    Für Partitionierte Tabellen Indizes nach Möglichkeit auch partitionieren (LOCAL), insbesondere dann wenn die Partitionen unterschiedlich aktuelle Dateninhalte physisch trennen.
    Durch Partitionierung kann oftmals der BLevel des Index reduziert werden.
    Für Unqiue Indizes gilt dies nur dann, wenn das Partitionierungskriterium mit den ersten Feld(ern) des Index übereinstimmt.
    Negativ wirkt sich allerdings der n-fache Zugriff auf Index bei Suche aus, wenn Partition-Key ungleich dem indizierten Feld ist und Partition-Key nicht Bestandteil des Filters ist.

  dragnet_helper_12_name:                                   Local-Partitionierung von Unique Indizes mit Partition-Key=Index-Spalte
  dragnet_helper_12_desc: |-
    Unqiue Indizes lassen sich auch local partitionieren, wenn der Partition-Key in identischer Folge Bestandteil des Index ist.
    Somit kann auch für Zugriffe über diese Indizes Partition-Pruning auf Index-Ebene genutzt werden sowie möglicherweise der BLevel des Index reduziert werden.

  dragnet_helper_13_name:                                   Local-Partitionierung mit Overhead im Zugriff
  dragnet_helper_13_desc: |-
    Local-Partitionierung nach Spalten, die nicht im Index indiziert sind, führt zum Zugriff auf alle Partitionen des Index bei Range Scan oder Unique Scan.
    Bei frequenter Nutzung des Index führt dies bei großen Partitionsanzahlen zu unnötig hohen Buffer Gets.
    Global Partitionierung nach dem Index-Kriterium kann dieses Verhalten abstellen.

  dragnet_helper_14_name:                                   "Identifikation von Indizes mit nur einem oder wenigen Schlüssel-Werten im Index"
  dragnet_helper_14_desc: |-
    Für Indizes mit nur einem oder wenigen Schlüsseln kann die Sinnfrage gestellt werden.
    Ausnahme: Index auch mit nur einem Schlüssel kann sinnvoll sein zur Differenzierung zwischen NULL und NOT NULL.
    Indizes mit nur einem Schlüssel und keinen NULLs in indizierten Feldern können i.d.R. entfernt werden.
    Bei Nutzung des Index zur Absicherung von Foreign Keys kann oftmals auf den Index verzichtet werden
    da der resultierende FullTableScan auf der referenzierenden Tabelle bei Delete auf der referenzierten Tabelle billigend in Kauf genommen werden kann.
  dragnet_helper_14_param_1_hint:                           Mindestanzahl Rows des betrachteten Index
  dragnet_helper_14_param_1_name:                           Min. Anzahl Rows des Index
  dragnet_helper_14_param_2_hint:                           Maximale Anzahl von eindeutigen Schlüsselwerten im betrachteten Index
  dragnet_helper_14_param_2_name:                           Max. Anzahl Schlüsselwerte des Index




  dragnet_helper_3_12_name:                                 "Suboptimale Konfigrations-Parameter der DB"
  dragnet_helper_3_12_desc: |-
    Ermittlung von suboptimalen bzw. inkompatiblen Parametrisierungen der Datenbank


  dragnet_helper_50_desc: |-
    Tabellen-Komprimierung (COMPRESS FOR xxx) reduziert I/O-Aufwände durch Verbesserung der Cache-Hit-Rate.
    Reduzierung der Größe der Tabellen durch Komprimierung um 1/3 bis 1/2 möglich.
    Min. 20% Reduktion der Größe sowie Relevanz von I/O sollte vorhanden sein, um CPU-Overhead für Komprimierung/Dekomprimierung zu kompensieren.
  dragnet_helper_50_name:                                    Evtl. sinnvolle Komprimierung von Tabellen
  dragnet_helper_50_param_1_hint:                            Mindestanzahl Leaf-Blocks / Key

  dragnet_helper_51_desc: |-
    Für die Sicherstellung der referentiellen Integrität sollten dringlich technische Schlüssel statt fachlicher Ausdrücke verwendet werden.
    Auf die kritische Verwendung fachlicher Schlüssel kann oft zurückgeschlossen werden durch Existenz von Referenzen auf mehrspaltige Primary Keys.
  dragnet_helper_51_name:                                   Verwendung von mehrspaltigen Primary Keys als Referenz-Ziel (fachliche statt technischer Schlüssel)

  dragnet_helper_52_desc: |-
    Sie sollten ein minimales Auditing (Aufzeichen) von DDL-Operationen vornehmen für die Nachvollziehbarkeit problematischer DDL-Aktionen.
    Die Audit-Daten werden im Regelfall aufgezeichnet in Tabelle sys.Aud$.
  dragnet_helper_52_name:                                   Fehlende vorgeschlagene Audit-Optionen

  dragnet_helper_53_desc: |-
    Lang laufende offene Transaktionen bergen die Gefahr von Lock-Eskalationen in OLTP-Systemen.
    Schreibende Zugriffe sollten an das Ende von Prozess-Transaktionen verlagert werden, um Sperr-Zeiten bis zum Commit möglichst kurz zu halten.
    Transaktionen in OLTP-Systemen sollten kurz genug sein, um eventuelle konkurrierende Sperren unter der Wahrnehmungsgrenze zu halten.
  dragnet_helper_53_name:                                   Lang laufende Transaktionen aus SGA (gv$Active_Session_History)

  dragnet_helper_54_desc: |-
    Lang laufende offene Transaktionen bergen die Gefahr von Lock-Eskalationen in OLTP-Systemen.
    Schreibende Zugriffe sollten an das Ende von Prozess-Transaktionen verlagert werden, um Sperr-Zeiten bis zum Commit möglichst kurz zu halten.
    Transaktionen in OLTP-Systemen sollten kurz genug sein, um eventuelle konkurrierende Sperren unter der Wahrnehmungsgrenze zu halten.
  dragnet_helper_54_name:                                   Lang laufende Transaktionen aus AWR-Historie (DBA_Hist_Active_Sess_History)

  dragnet_helper_55_desc: |-
    Kartesische Joins können dann problematisch sein, wenn zwei große Mengen ohne Join-Bedingung miteinander verknüpft werden.
    Hinweis auf Probleme können die Laufzeit des SQL sowie die Größe der beteiligten Tabellen sein.
    Ausgewertet wird die aktuelle SGA (GV$SQL_Plan)
  dragnet_helper_55_name:                                   Problematische Nutzung von kartesischen Joins (Auswertung aktuelle SGA)
  dragnet_helper_55_param1_name:                            Ausschluss eines Objekt-Owners
  dragnet_helper_55_param1_desc:                            Ausschluss eines einzelnen Objekt-Owners aus dem Ergebnis
  dragnet_helper_55_param2_name:                            Minimum totale Laufzeit des SQL (Sek.)
  dragnet_helper_55_param2_desc:                            Minimum der Summe der totalen Laufzeit des SQL in SGA in Sekunden


  dragnet_helper_56_desc: |-
    Kartesische Joins können dann problematisch sein, wenn zwei große Mengen ohne Join-Bedingung miteinander verknüpft werden.
    Hinweis auf Probleme können die Laufzeit des SQL sowie die Größe der beteiligten Tabellen sein.
    Ausgewertet wird die AWR-Historie (DBA_Hist_SQL_Plan)
  dragnet_helper_56_name:                                   Problematische Nutzung von kartesischen Joins (Auswertung AWR-Historie)
  dragnet_helper_56_param1_name:                            Ausschluss eines Objekt-Owners
  dragnet_helper_56_param1_desc:                            Ausschluss eines einzelnen Objekt-Owners aus dem Ergebnis
  dragnet_helper_56_param2_name:                            Minimum totale Laufzeit des SQL (Sek.)
  dragnet_helper_56_param2_desc:                            Minimum der Summe der totalen Laufzeit des SQL in SGA in Sekunden

  dragnet_helper_57_desc: |-
    Bei großer Anzahl Child-Cursoren eines Statements (> 500) steigt das Risiko von latch waits und kritischer CPU-Last bei Parsen und Ausführung von SQL
    Die folgenden Zähler für Gründe zeigen warum beim Parsen neue Child-Cursoren erzeugt wurden
    Dokumentation ist hier verfügbar: http://docs.oracle.com/cd/E16655_01/server.121/e17615/refrn30254.htm#REFRN30254
  dragnet_helper_57_name:                                   Kritische Anzahl von Child-Cursoren einer SQL-ID
  dragnet_helper_57_param1_name:                            Min. Anzahl Childs je SQL-ID
  dragnet_helper_57_param1_desc:                            Minimale Anzahl Child-Cursoren je SQL-ID für Anzeige

  dragnet_helper_58_desc: |-
    Bei Nutzung der Funktion NVL für alternative Werte wenn NULL wird der Alternativ-Zweig immer ausgeführt, unabhängig davon, ob der erste Parameter des NVL gleich NULL ist oder nicht.
    Bei Deklaration aufwendiger Berechnungen als Alternative empfiehlt sich die Nutzung von COALESCE statt NVL, wo der Alternativ-Parameter nur berechnet wird, wenn der Entscheidungsparameter auch wirklich NULL ist.
  dragnet_helper_58_name:                                   Aufruf von Funktionen mit Parametern in Alternativ-Zweig von NVL
  dragnet_helper_58_param1_name:                            Min. Laufzeit des SQL in Sekunden
  dragnet_helper_58_param1_desc:                            Minimale Laufzeit des SQL in Sekunden für Berücksichtigung in der Abfrage

  dragnet_helper_59_param_2_name:                           Minimale Anzahl Fetches je Execution
  dragnet_helper_59_param_2_hint:                           Minimale Anzahl Fetches je Execution für Aufnahme in Result

  dragnet_helper_60_param_1_name:                           Minimale Anzahl Fetches je Execution
  dragnet_helper_60_param_1_hint:                           Minimale Anzahl Fetches je Execution für Aufnahme in Result


  dragnet_helper_61_desc: |-
    Primärschlüssel-Spalten sollten i.d.R. unveränderlich sein, insbesondere wenn drauf referenziert wird.
    Das Überschreiben mit iddentischen Werten verursacht unnötig Aufwand für Index-Maintenance.
    Daher sollten Primärschlüssel-Spalten nicht in der SET-Klausel von Updates enthalten sein.
  dragnet_helper_61_name:                                   Evtl. unnötiger Update von Primärschlüssel-Spalten
  dragnet_helper_61_param_1_name:                           Minimale Anzahl Executions
  dragnet_helper_61_param_1_hint:                           Minimale Anzahl Executions für Aufnahme in Result

  dragnet_helper_62_desc: |-
    Länger inaktive Sessions mit offenen Transaktionen können Hinweis sein auf:
    - nicht abgeschlossene manuelle Aktivitäten z.B. aus Transkationssteuerung über GUI
    - an Connection-Pools zurückgegebene Sessions ohne abgeschlossene Transaktion
  dragnet_helper_62_name:                                   Inaktive Sessions mit offenen DML-Transaktionen
  dragnet_helper_62_param_1_name:                           Minimale Dauer (Sekunden) seit letzter Aktivät der Session
  dragnet_helper_62_param_1_hint:                           Minimale Dauer in Sekunden seit dem Ende der letzten Aktivtät der Session

  dragnet_helper_63_desc: |-
    Die Anzahl der verfügbaren PQ-Server ist eine limitierte Resoure, damit ist der Default-Degree der Parallelisierung oft zu hoch für produktive Anwendung,
    besonders auf Maschinen mit vielen CPU-Kernen.
    Die Überbuchung der PQ-Server kann zur seriellen Abarbeitung anderer als parallel abgearbeitet erwarteter SQLs führen.
  dragnet_helper_63_name: |-
    Parallel Query: Degree der Parallelisierung (Anzahl genutzter PQ Server) höher als Limit für einfache SQL-Ausführung
  dragnet_helper_63_param_2_name:                           Limit für Anzahl PQ-Server
  dragnet_helper_63_param_2_hint:                           Limit für Anzahl PQ-Server, Überschreitungen werden hier angezeigt

  dragnet_helper_64_desc: |-
    Für niemals für Selektionen genutzte Tabellen kann kritisch die Daseinsberechtigung hinterfragt werden.
    Dies beinhaltet auch Tabellen, die zwar geschrieben aber nie gelesen werden.
  dragnet_helper_64_name:                                   Ermittlung nicht genutzter Tabellen
  dragnet_helper_64_param_1_hint:                           Anzahl Tage rückwärts von jetzt für Auswertung der AWR-Historie bzgl. Match im SQL-Text
  dragnet_helper_64_param_1_name:                           Betrachtung der AWR-Historie für SQL rückwärts in Tagen
  dragnet_helper_64_param_2_hint:                           Anzahl Tage rückwärts von jetzt für Auswertung der AWR-Historie bzgl. Vorkommen im Explain-Plan'
  dragnet_helper_64_param_2_name:                           Betrachtung der AWR-Historie für Plan rückwärts in Tagen

  dragnet_helper_65_desc: |-
    In vielen Konstellationen ist wichtig, nicht mehr produktive Altdaten auch wieder aus dem System zu entfernen.
    Bei größerem Abstand der Ermittlung von analyze-Info hilft u.g. Statement zum Ermitteln von Lücken im Housekeeping.
    Es werden ausgewiesen die Inserts und Updates seit der letzten Tabellen-Analyse für Tabellen ohne Deletes.
  dragnet_helper_65_name:                                   Fehlendes Housekeeping bei Massendaten

  dragnet_helper_66_desc: |-
    Ungenutzte Spalten, die nur NULL-Werte enthalten, können möglicherweise entfernt werden.
    Jede NULL-Spalte eines Records belegt ein Byte, wenn nicht alle nachfolgenden Spalten auch NULL sind.
    Ab 11g können statt dessen virtuelle Spalten definiert werden, wenn Struktur fest vorausgesetzt wird (SAP etc.).
  dragnet_helper_66_name:                                   Ermittlung nicht genutzter Spalten (alle Werte = NULL)

  dragnet_helper_67_desc: |-
    Für Spalten großer Tabellen mit wenigen DISTINCT-Werten kann Sinn hinterfragt werden, evtl. redundante Aussage zu weiteren Spalten der Tabelle,
    die in Stammdaten hinter n:1-Relationen verlagert werden kann (Normalisierung)
  dragnet_helper_67_name:                                   Ermittlung wenig aussagefähiger Spalten

  dragnet_helper_68_desc: |-
    Für Unused gesetzte Spalten lohnt möglicherweise Reorganisation per ALTER TABLE DROP UNSED COLUMNS oder Neuaufbau der Tabelle.
  dragnet_helper_68_name:                                   Unused markierte jedoch nicht physisch gelöschte Spalten

  dragnet_helper_69_desc: |-
    chained rows verursachen das Nachlesen von Migrationsblöcken bei Zugriff auf einen Record, der nicht vollständig im aktuellen Block enthalten ist.
    Durch Anpassen PCTFREE sowie Reorganisation der betroffenen Tabelle lassen sich chained rows vermeiden.

    Die Selektion ist nicht direkt ausführbar. Bitte PL/SQL-Code kopieren und extern in SQL*Plus ausführen !!!
  dragnet_helper_69_name:                                   Ermittlung von chained rows von Tabellen

  dragnet_helper_70_desc: |-
    IndexFullScan-Operationen auf großen Indizes können oftmals erfolgreich auf parallelen DirectRead per IndexFastFullScan umgesetzt werden, wenn die Sortierung des Index für das Result nicht relevant ist.
    Wenn der Optimizer die entscheidung nicht eigenständig trifft, sind hierzu die Hints /*+ PARALLEL_INDEX(Alias, Degree) INDEX_FFS(Alias) */ zu verwenden.
  dragnet_helper_70_name:                                   Optimierbare Index Full-Scan Operationen

  dragnet_helper_71_desc: |-
    FullTableScan-Zugriffe sind dann kritisch, wenn nur kleine Anteile einer Tabelle für die Selektion relevant sind, andererseits sinnvoll bei Verarbeitung kompletter Tabelleninhalte.
    Fehl am Platze sind FullTableScans i.d.R. in OLTP-artigen Zugriffen (kleine Zugriffszeit, häufige Zugriffe).
  dragnet_helper_71_name:                                   Optimierbare FullTableScan-Operationen nach Executions

  dragnet_helper_72_desc: |-
    FullTableScan-Zugriffe sind dann kritisch, wenn nur kleine Anteile einer Tabelle für die Selektion relevant sind, andererseits sinnvoll bei Verarbeitung kompletter Tabelleninhalte.
    Fehl am Platze sind FullTableScans i.d.R. in OLTP-artigen Zugriffen (kleine Zugriffszeit, häufige Zugriffe).
  dragnet_helper_72_name:                                   Optimierbare FullTableScan-Operationen nach Executions und Rows_Processed

  dragnet_helper_73_desc: |-
    Lang laufende Foreign Key-Prüfungen bei Delete werden oftmals durch fehlende Indizierung der referenzierenden Tabelle verursacht.
  dragnet_helper_73_name:                                   Optimierbare FullTableScan-Operationen bei lang laufenden Foreign-Key-Prüfungen bei Delete

  dragnet_helper_74_desc: |-
    Verzögerungen beim Wegschreiben des Logbuffers durch Logwriter führen zu „log file sync“-Wait-Events, z.B. bei Commit.
    Schreibende Operationen (Insert/Update/Delete), die während „log file sync“ nicht in Logbuffer schreiben können, führen zu „log buffer space“-Wait-Events.
    Anforderungen auf Blocktransfer im RAC-Verbund führen zu „gc buffer busy“-Wait-Events, wenn die betreffenden Blöcke in der liefernden Instanz gerade von „log buffer space“ bzw. „log file sync“ betroffen sind.
    Die Wahrscheinlichkeit eines „log buffer space“-Events ist von der Häufigkeit schreibender Operationen abhängig. Die folgenden Selektionen ermitteln häufig ausgeführte schreibende Statements als Kandidaten.
    Lösung besteht in der Zusammenfassung mehrerer Records (Bulk-Berarbeitung) bei Schreibzugriffen.
  dragnet_helper_74_name:                                   Schreibende Zugriffe nach Executions (Aktuelle SGA)
  dragnet_helper_74_param_1_hint:                           Minimale anzahl geschriebene Rows für Aufnahme in Selektion
  dragnet_helper_74_param_1_name:                           Minimale Anzahl geschriebene Rows

  dragnet_helper_75_desc: |-
    Verzögerungen beim Wegschreiben des Logbuffers durch Logwriter führen zu „log file sync“-Wait-Events, z.B. bei Commit.
    Schreibende Operationen (Insert/Update/Delete), die während „log file sync“ nicht in Logbuffer schreiben können, führen zu „log buffer space“-Wait-Events.
    Anforderungen auf Blocktransfer im RAC-Verbund führen zu „gc buffer busy“-Wait-Events, wenn die betreffenden Blöcke in der liefernden Instanz gerade von „log buffer space“ bzw. „log file sync“ betroffen sind.
    Die Wahrscheinlichkeit eines „log buffer space“-Events ist von der Häufigkeit schreibender Operationen abhängig. Die folgenden Selektionen ermitteln häufig ausgeführte schreibende Statements als Kandidaten.
    Lösung besteht in der Zusammenfassung mehrerer Records (Bulk-Berarbeitung) bei Schreibzugriffen.
  dragnet_helper_75_name:                                   Schreibende Zugriffe nach Executions (AWR-Historie)
  dragnet_helper_75_param_2_hint:                           Minimale anzahl geschriebene Rows für Aufnahme in Selektion
  dragnet_helper_75_param_2_name:                           Minimale Anzahl geschriebene Rows

  dragnet_helper_76_desc: |-
    Auf Basis der Active Session History lassen sich Ausreiser der DB-Laufzeit je Modul ausweisen.
    Die Betrachtungseinheit wird über date format picture der TRUNC-Funktion festgelegt (DD=Tag, HH24=Stunde etc.)
  dragnet_helper_76_name:                                   Erheblich größere Laufzeit je Module gegenüber Durchschnitt über längere Zeit

  dragnet_helper_77_desc: |-
    Für langlaufende Statements kann unter Umständen die Nutzung des Features Parallel Query die Laufzeit drastisch reduzieren.
  dragnet_helper_77_name:                                   Langlaufende Statements ohne Nutzung Parallel Query (Auswertung SGA)

  dragnet_helper_78_desc: |-
    Für langlaufende Statements kann unter Umständen die Nutzung des Features Parallel Query die Laufzeit drastisch reduzieren.
  dragnet_helper_78_name:                                   Langlaufende Statements ohne Nutzung Parallel Query (Auswertung AWR-Historie)

  dragnet_helper_79_desc: |-
    Bei Nutzung Parallel Query können versehentlich nicht parallelisierte Zugriffe auf größere Strukturen die Laufzeit des Statements drastisch verlängern.
    Steuernde INDEX-RANGE-SCAN für NestedLoop-Kaskaden auslagern in WITH … /*+ MATERIALIZE */ und parallelisieren.
    Selektion beleuchtet die aktuelle SGA.
  dragnet_helper_79_name:                                   Parallelisierte Statements mit nicht parallelisierten Anteilen (Auswertung SGA)

  dragnet_helper_80_desc: |-
    Bei Nutzung Parallel Query können versehentlich nicht parallelisierte Zugriffe auf größere Strukturen die Laufzeit des Statements drastisch verlängern.
    Steuernde INDEX-RANGE-SCAN für NestedLoop-Kaskaden auslagern in WITH … /*+ MATERIALIZE */ und parallelisieren.
    Selektion beleuchtet die AWR-Historie.
  dragnet_helper_80_name:                                   Parallelisierte Statements mit nicht parallelisierten Anteilen (Auswertung AWR-Historie)

  dragnet_helper_81_desc: |-
    Nicht per PARALLEL_ENABLE zur parallelen Verarbeitung zugelassene stored functions führen zur Serialisierung der Verarbeitung bei Verwendung der Parallel Query-Option im Statement.
    Für die angelisteten Funktionen ist Erweiterung um Attribut PARALLEL_ENABLE zu untersuchen.
  dragnet_helper_81_name:                                   Parallel ausgeführte SQL mit Nutzung Stored Functions ohne PARALLEL_ENABLE

  dragnet_helper_82_desc: |-
    Teile von parallel verarbeiteten Statements können trotzdem seriell abgearbeitet werden und die Ergebnisse des Teilschrittes werden per Broadcast parallelisiert.
    Für kleinere Datenstrukturen ist dies oft so gewollt, für größere Datenstrukturen fehlen möglicherweise PARALLEL-Anweisungen.
    Das SQL listet alle Statements mit 'PARALLEL_FROM_SERIAL'-Verarbeitung nach Full-Scan auf Objekten als Kandidaten für vergessene Parallelisierung.
  dragnet_helper_82_name:                                   Parallele Statements mit serieller Abarbeitung von Teilprozessen

  dragnet_helper_83_desc: |-
    Für Select- / Update- / Delete-Statements, deren Zugriffskriterien niemals zu Treffern führen, kann evtl. die Sinnfrage gestellt werden.
    Es könnte sich aber auch um seltene Prüfungen handeln, bei denen kein Treffer das erwartete und zu testende Resultat ist.
  dragnet_helper_83_name:                                   Evtl. unnötige Ausführung von Statements wenn Selects/Updates/Deletes immer ohne Treffer

  dragnet_helper_84_desc: |-
    Single-Row-Update-Statements mit einschränkendem Filter in WHERE-Bedingung des Updates lassen sich oft beschleunigen durch Verlagerung des Filters in vorherige Selektion,
    die als Massendatenoperation effektiver ausgeführt und optional mittels ParallelQuery parallelisiert werden kann.
  dragnet_helper_84_name:                                   Evtl. unnötige Ausführung von Statements wenn Updates unnötigem Filter in WHERE-Bedingung haben (Auswertung SGA)

  dragnet_helper_85_desc: |-
    Single-Row-Update-Statements mit einschränkendem Filter in WHERE-Bedingung des Updates lassen sich oft beschleunigen durch Verlagerung des Filters in vorherige Selektion,
    die als Massendatenoperation effektiver ausgeführt und optional mittels ParallelQuery parallelisiert werden kann.
  dragnet_helper_85_name:                                   Evtl. unnötige Ausführung von Statements wenn Updates unnötigem Filter in WHERE-Bedingung haben (Auswertung AWR-Historie)

  dragnet_helper_86_desc: |-
    Die Abfrage mit IS NULL als WHERE-Bedingung führt oftmals zu FullTableScan obwohl evtl. nur wenige NULL-Records selektiert werden.
    Lösung kann sein: Indizierung des mit IS NULL abgefragten Feldes durch speziellen Index, der auch NULL-Werte indiziert und Nutzung des Funktionsausdruckes im Select an Stelle von IS NULL.
    Beispiel: Indizierung von NVL(Column,0)
  dragnet_helper_86_name:                                   Lang laufende Full Table Scans durch IS NULL-Abfrage (ab 11g)

  dragnet_helper_87_desc: |-
    Zugriffe auf DB-Blöcke im Cache der DB (db-block-gets, consistent reads) werden dann kritisch hinsichtlich des provozierens von 'cache buffers chains'-Latchwaits wenn:
    - in massiver Häufigkeit auf einige wenige Blöcke lesend oder schreibend zugegriffen wird (HotBlocks im Buffer-Cache)
    - exorbitant viele Blöcke gelesen werden (kritsch selbst dann wenn diese weit verteilt im Cache liegen und keine HotBlocks bilden)
    Für beide Konstellationen lassen sich problematische Statements identifizieren durch Bewertung nach der Spitze der Anzahl Blockzugriffe zwischen zwei AWR-Snapshots.
  dragnet_helper_87_name:                                   Übermäßige Anzahl Zugriffe auf Cache-Buffer
  dragnet_helper_87_param_1_hint:                           Maximale Anzahl Trefferzeilen im Resultat
  dragnet_helper_87_param_1_name:                           Maximale Anzahl Trefferzeilen im Resultat

  dragnet_helper_88_desc: |-
    Bei oft ausgeführten Statements kann es sich lohnen, kleine Tabellen per Caching-Funktionen statt SQL zuzugreifen.
    Damit reduziert sich CPU-Belastung und Gefahr von „Cache Buffers Chains“ Latch-Waits.
    Ab 11g können stored functions mit function result caching für diesen Zweck genutzt werden.
  dragnet_helper_88_name:                                   Hochfrequenter Zugriff auf kleine Objekte
  dragnet_helper_88_param_1_hint:                           Minimale Anzahl Executions für Aufnahme in Selektion
  dragnet_helper_88_param_1_name:                           Minimale Anzahl Executions

  dragnet_helper_89_desc: |-
    Bei größeren Results je Execution lohnt sich der Array-Zugriff auf mehrere Records  je Fetch statt Einzelzugriff.
    Damit moderate Reduktion von CPU-Belastung und Laufzeit
  dragnet_helper_89_name: |-
    Unnötig hohe Fetch-Anzahl wegen fehlender Array-Nutzung: Auswertung SGA

  dragnet_helper_90_desc: |-
    Bei größeren Results je Execution lohnt sich der Array-Zugriff auf mehrere Records  je Fetch statt Einzelzugriff.
    Damit moderate Reduktion von CPU-Belastung und Laufzeit
  dragnet_helper_90_name: |-
    Unnötig hohe Fetch-Anzahl wegen fehlender Array-Nutzung: Auswertung AWH-Historie

  dragnet_helper_91_desc: |-
    Bei geringer Anzahl Rows je Execution und hoher Execution-Zahl lohnt sich die Bündelung von Schreibzugriffen in Array-Operationen bzw. PL/SQL-FORALL-Operationen wenn sie in selber Transaktion stattfinden.
    Damit moderate Reduktion von CPU-Belastung und Laufzeit.
  dragnet_helper_91_name:                                   Schreibende Statements mit unnötig hoher Execute-Anzahl wegen fehlender Array-Verarbeitung

  dragnet_helper_92_desc: |-
    Mit dieser Selektion lassen sich aus den AWR-Daten Wechsel der Ausführungspläne unveränderter SQL‘s ermitteln.
    Betrachtet wird dabei die aufgezeichnete Historie ausgeführter Statements
  dragnet_helper_92_name:                                   Identifikation von Statements mit wechselndem Ausführungsplan aus Historie

  dragnet_helper_93_desc: |-
    Oft ausgeführte Nested-Loop-Operationen auf große (schwer zu cachende) Tabellen können Laufzeit-Treiber sein.
    Für die angelisteten Statements ist die Variante „Hash-Join“ zu untersuchen.
    Dieses Statement betrachtet nur die Daten der aktuellen RAC-Instance(Login). Statement bitte für jede RAC-Instanz einzeln ausführen auf Grund utopische Laufzeit bei Zugriff auf GV$-Tabellen über RAC-Instanzen hinweg.
  dragnet_helper_93_name:                                   Nested-Loop-Join auf große Tabellen mit großem Result des SQL (Test per SGA-Statement-Cache)
  dragnet_helper_93_param_1_hint:                           Minimale Anzahl Rows processed / Execution als Schwellwert für mgl. Ineffizienz NestedLoop
  dragnet_helper_93_param_1_name:                           Minimale Anzahl Rows processed / Execution

  dragnet_helper_94_desc: |-
    Vielfache Ausführung von Full-Scan Operationen per Iteration in Nested Loop Join kann zu exorbitanten Blockzugriffen führen und damit  massiv CPU und I/O-Ressourcen beanspruchen sowie Cache Buffers Chains Latch-Waits provozieren.
    Legitim ist ein solcher Zugriff allerdings, wenn steuerndes Result des Nested Loop einen oder wenige Records liefert.
    Statement muss für jede RAC-Instanz separat angewandt werden, da wegen akzeptabler akzeptabler Laufzeit nur die aktuell angemeldete Instanz geprüft wird.
  dragnet_helper_94_name:                                   Iteration im Nested-Loop-Join gegen Full-Scan-Operation

  dragnet_helper_95_desc: |-
    Auslöser von impliziten Typ-Konvertierungen ist oftmals versehentlich mit falschem Typ gebundene Bindevariable.
    Die Konvertierung verursacht möglicherweise unnötig CPU-Last auf der DB-Maschine.
    Durch die Ansprache der Spalte per INTERNAL_FUNCTION statt direkt wird die mögliche Nutzung von Indizes für den Zugriff verhindert.
    In diesen Fällen sollte tunlichst der entsprechende Datentyp für die Variablenbindung verwendet werden.
  dragnet_helper_95_name:                                   Implizite Konvertierungen per INTERNAL_FUNCTION

  dragnet_helper_96_desc: |-
    Statements mit hochfrequent gelesenen Blöcken im DB-Cache laufen Gefahr, durch 'cache buffers chains'-LatchWaits ausgebremst zu werden.
    Die Abfrage ermittelt Objekte mit verdächtig hohen Block-Zugriffen im Verhältnis zur Größe (viele Zugriffe auf wenige Blöcke).
  dragnet_helper_96_name: |-
    Identifikation von HotBlocks im DB-Cache: Viele Zugriffe auf kleine Objekte
  dragnet_helper_96_param_1_hint:                           Maximale Anzahl Rows der betrachteten Table für Aufnahme in Selektion
  dragnet_helper_96_param_1_name:                           Maximale Anzahl Rows der Table

  dragnet_helper_97_desc: |-
    Views mit Abhängigkeit von anderen Views (evtl. noch mehrstufig hierarchisch abhängig) bergen das Risiko,
    unnötig Daten von Objekten zu selektieren, die für das auslösende SQL gar nicht relevant sind.
    Der Optimizier ist hier nicht mehr in der Lage, irrelevante Teile eines Views zu erkennnen und vom Ausführungsplan zu entfernen.
    Als sinnvolles Architektur-Pattern hat sich bewährt, Views möglichst nur in einer Dimension zu benutzen ohne Abhängigkeit von anderen Views.
  dragnet_helper_97_name: |-
    Kaskadierende Views (Views mit Abhängigkeit von anderen Views)

  dragnet_helper_98_desc: |-
    Views mit Abhängigkeit von anderen Views (evtl. noch mehrstufig hierarchisch abhängig) bergen das Risiko,
    unnötig Daten von Objekten zu selektieren, die für das auslösende SQL gar nicht relevant sind.
    Der Optimizier ist hier nicht mehr in der Lage, irrelevante Teile eines Views zu erkennnen und vom Ausführungsplan zu entfernen.
    Als sinnvolles Architektur-Pattern hat sich bewährt, Views möglichst nur in einer Dimension zu benutzen ohne Abhängigkeit von anderen Views.
    --- Selektion kann länger dauern ---
  dragnet_helper_98_name: |-
    SQLs mit kaskadierende Views (Views mit Abhängigkeit von anderen Views), Auswertung der aktuellen SGA

  dragnet_helper_99_desc: |-
    Views mit Abhängigkeit von anderen Views (evtl. noch mehrstufig hierarchisch abhängig) bergen das Risiko,
    unnötig Daten von Objekten zu selektieren, die für das auslösende SQL gar nicht relevant sind.
    Der Optimizier ist hier nicht mehr in der Lage, irrelevante Teile eines Views zu erkennnen und vom Ausführungsplan zu entfernen.
    Als sinnvolles Architektur-Pattern hat sich bewährt, Views möglichst nur in einer Dimension zu benutzen ohne Abhängigkeit von anderen Views.
    --- Selektion kann länger dauern ---
  dragnet_helper_99_name: |-
    SQLs mit kaskadierende Views (Views mit Abhängigkeit von anderen Views), Auswertung der AWR-Historie

  dragnet_helper_100_desc: |-
    Delete-Operationen auf Tabellen ohne einschränkenden Filter sollten ersetzt werden durch TRUNCATE TABLE.
    Dies reduziert Laufzeit, REDO-Aufkommen und sichert das Rücksetzen der High-Water-Mark
  dragnet_helper_100_name: |-
    DELETE-Operationen ersetzbar durch TRUNCATE

  dragnet_helper_101_desc: |-
    Indizes mit hoher Datenfluktuation und Schieflage (z.B. fortlaufende Nummern) scannen nach Record-Löschungen sukzessive mehr DB-Blöcke beim Zugriff.
    Problematisch ist insbesondere Zugriff auf erste Records solcher moving windows.
    Evtl. notwendige Reorganisation kann z.B. per ALTER INDEX SHRINK SPACE COMPACT oder ALTER INDEX COALESCE erfolgen für laufende OLTP-Systeme oder ALTER INDEX REBUILD in Downtimes.
    Diese Selektion sucht nach SQL-Statements in aktueller SGA mit Zugriff auf Indizes, die möglicherweise eine Reorganisation benötigen.
  dragnet_helper_101_name: |-
    Identifikation von HotBlocks im DB-Cache: Suboptimale Indizes
  dragnet_helper_101_param_1_hint:                           Maximale Anzahl Operationen im Execution Plan des SQL
  dragnet_helper_101_param_1_name:                           Maximale Anzahl Operationen im Execution Plan
  dragnet_helper_101_param_2_hint:                           Minimale Anzahl Executions für Aufnahme in Selektion
  dragnet_helper_101_param_2_name:                           Minimale Anzahl Executions
  dragnet_helper_101_param_3_hint:                           Maximale Anzahl Bindevariablen im Statement
  dragnet_helper_101_param_3_name:                           Maximale Anzahl Bindevariablen
  dragnet_helper_101_param_4_hint:                           Minimale Anzahl Rows processed / Execution
  dragnet_helper_101_param_4_name:                           Minimale Anzahl Rows processed / Execution
  dragnet_helper_101_param_5_hint:                           Minimale Anzahl Buffer gets / Row
  dragnet_helper_101_param_5_name:                           Minimale Anzahl Buffer gets / Row

  dragnet_helper_102_desc: |-
    Das Update indizierter Spalten einer Tabelle kostet Aufwand für Index-Maintenance (Entfernen und Neueinstellen des Index-Eintrages) auch wenn sich der Inhalt des Feldes gar nicht geändert hat.
    Unter diesem Aspekt ist es sinnvoll, indizierte Spalten häufig upzudatender Tabellen deren Inhalte sich nie ändern sollten aus dem Update-Statement zu entfernen.
    Dies gilt insbesondere für  dynamisch generierte Statements z.B. aus OR-Mappern, die per Default alle Spalten einer Tabelle enthalten.
  dragnet_helper_102_name: |-
    Prüfung der Notwendigkeit des Updates indizierter Spalten
  dragnet_helper_102_param_1_hint:                           Minimale Anzahl Rows processed für Aufnahme in Selektion
  dragnet_helper_102_param_1_name:                           Minimale Anzahl Rows processed

  dragnet_helper_103_desc: |-
    Für Cost-based Optimizer sollten System-Statistiken hinreichend aktuell sein und die Realität beschreiben
  dragnet_helper_103_name: |-
    System- Statistiken: Prüfung auf aktuelle Analyze-Info

  dragnet_helper_104_desc: |-
    Für Cost-based Optimizer sollten Objekt-Statistiken hinreichend aktuell sein
  dragnet_helper_104_name: |-
    Objekt-Statistiken: Prüfung auf aktuelle Analyze-Info (Tables)
  dragnet_helper_104_param_1_hint:                           Falls Analyze-Info existiert, ab welchem Alter Aufnahme in Selektion
  dragnet_helper_104_param_1_name:                           Mindestalter existierender Analyse in Tagen

  dragnet_helper_105_desc: |-
    PX COORDINATOR FORCED SERIAL im Execution-Plan zeigt, dass der Optimizer parallele Ausführung annimmt, dann aber Hinderungsgründe düe parallele Ausführung feststellt (z.B. stored functions ohne PARALLEL_ENABLE).
    Die Operationen unter der Zeile des Ausführungsplans werden in der Realität nicht parallel ausgeführt auch wenn der Optimizer sie für parallele Ausführung markiert hat!
  dragnet_helper_105_name:                                  Statements mit geplanter paralleler Execution forced to serial

  dragnet_list_dragnet_sql_result_no_result:                SQL brachte kein Result

  dragnet_show_selection_do_sql_caption:                    Selektion ausführen
  dragnet_show_selection_do_sql_hint:                       Ausführen des ausgewählten Reports
  dragnet_show_selection_header:                            Rasterfahndung nach Performance-Bottlenecks und Nutzung von Anti-Pattern
  dragnet_show_selection_select_hint:                       Auswahl des Rasterfahndungs-SQL
  dragnet_show_selection_show_sql_hint:                     Anzeige des auszuführenden SQL-Statements

  env_build_main_menu_repeat_hint:                          Wiederholen der letzten im Menü ausgewählten Aktion
  env_current_database:                                     Aktuelle Datenbank
  env_handling_hints:                                       Tips zur Bedienung
  env_handling_hint_generally_1:                            Systemweit werden vielfach Kontext-Informationen über MouseOver-Hints angeboten
  env_handling_hint_generally_2:                            Detaillierungen angezeigter Werte können über Klick auf Hyperlinks ausgelöst werden
  env_handling_hint_generally_3:                            Detaillierungen werden entweder inline z.B. im Tabellenfeld angezeigt oder in separaten Listen am unteren Seitenrand fortgesetzt
  env_handling_hint_1:                                      Sortieren der Tabellenanzeige durch Klick auf Spalten-Header
  env_handling_hint_2:                                      Sortieren nach mehreren Spalten durch aufeinanderfolgende Sortierung nach einzelnen Spalten
  env_handling_hint_3:                                      Such-Filter, optionale Diagramm-Darstellung sowie Excel-Export sind verfügbar über Kontext-Menü (rechter Mouse-Button)
  env_licensing_header:                                     Lizensierung

  env_set_database_xmem_line1:                              User %{user} hat kein Leserecht auf X$%{table_name_suffix} ! Damit sind einige wenige Funktionen von Panorama nicht nutzbar!
  env_set_database_xmem_line2: |-
    Variante 1: Anmelden mit Rolle SYSDBA
  env_set_database_xmem_line3: |-
    Variante 2: Ausführen als User SYS
  env_set_database_xmem_line4: |-
    Damit wird X$%{table_name_suffix} verfügbar unter Rolle SELECT ANY DICTIONARY
  env_set_database_mgmt_msg_false:                          ist für diese Datenbank markiert als nicht lizensiert
  env_set_database_mgmt_msg_true:                           ist für diese Datenbank markiert als lizensiert


  help_no_help_available:                                   Bisher leider keine Hilfe vorhanden für

  list_io_file_history_samples_hint:                        Anzeige der Zeitleiste der einzelnen Sample-Records

  list_session_statistic_historic_grouping_link_title:      Wait-States des SQL's in Active Session History im gegebenen Zeitraum anzeigen

  list_sql_detail_sql_id_childno_active_session_history_title: Anzeige der "Active Session History"-Einträge dieser SQL-ID

  login_authorization_hint:                                 Zusätzliche Autorisierung für spezielle Applikationen (z.B. NOA)
  login_caption:                                            Bitte gespeicherte Anmeldung auswählen oder<br>konkrete Anmeldeinformationen eingeben
  login_database_host_hint:                                 Host-Name bzw. IP-Ardesse
  login_database_sid_hint:                                  SID oder Service-Name der Datenbank
  login_lang_caption:                                       Sprache
  login_locale_title:                                       Auswahl Applikations-Sprache
  login_mode_caption:                                       Modus DB-Auswahl
  login_mode_title:                                         Auswahl Modus zur Identifikation der Datenbank
  login_role_caption:                                       Rolle
  login_save_login_caption:                                 Login speichern?
  login_save_login_hint:                                    Login-Info speichern für wiederholte Verwendung?
  login_saved_delete_confirmation:                          Wirklich die gespeicherte DB-Connect-Info löschen?
  login_saved_delete_caption:                               Löschen
  login_saved_delete_title:                                 Die ausgewählte gespeicherte DB-Verbindung löschen
  login_saved_login_title:                                  Mit der gespeicherten DB-Verbindung anmelden
  login_saved_logins_title:                                 Gespeicherte DB-Verbindungen aus früherer Nutzung
  login_submit_caption:                                     Anmelden
  login_title: |-
    Panorama: Login auf Ziel-DB
  login_tns_hint:                                           Auswahl Oracle TNS-Alias (aus tnsnames.ora des Servers)

  menu_current_caption:                                     Aktuell

  menu_dba_caption:                                         DBA Allgemein
  menu_dba_blocking_locks_historic_caption:                 Blocking Locks historisch
  menu_dba_blocking_locks_historic_hint:                    Anzeige historische Info zu Blocking Locks
  menu_dba_database_triggers_hint:                          Anzeige der global Datenbank-Trigger (z.B. LOGON-Trigger)
  menu_dba_explain_plan_hint:                               Anzeige Ausführungsplan eines SQL-Statements
  menu_dba_locks_hint:                                      Aktueller Lock-Status incl. Blocking Locks
  menu_dba_schema_audit_trail_hint:                         Anzeige von per Audit Trail geloggten Aktivitäten
  menu_dba_schema_ts_objects_hint:                          DB-Objekte nach Größe, Auslastung, Verschnitt
  menu_dba_parameter_hint:                                  Anlistung der aktiven Instance-Parameter
  menu_dba_redologs_hint:                                   Anlistung der Redo-Logs
  menu_dba_redologs_historic_hint:                          Anlistung historischer Info der Redo-Logs
  menu_dba_sessions_hint:                                   Anlistung der aktuellen Session-Info
  menu_dba_temp_usage_hint:                                 Aktuelle Nutzung Temp-Tablespace
  menu_dba_used_objects_caption:                            Objekte im Zugriff
  menu_dba_used_objects_hint: |-
    Aktuell im Zugriff befindliche Objekte (Vorsicht: Langsam auf großen Systemen)

  menu_historic_caption:                                    Historisch

  menu_io_iostat_detail_caption:                            I/O-Stat Detail Historie
  menu_io_iostat_detail_hint:                               I/O-Historie basierend auf DBA_Hist_IOStat_Detail
  menu_io_iostat_filetype_caption:                          I/O-Stat FileType Historie
  menu_io_iostat_filetype_hint:                             I/O-Historie basierend auf DBA_Hist_IOStat_FileType
  menu_io_caption:                                          I/O-Analyse
  menu_io_file_caption:                                     I/O Historie nach Files
  menu_io_file_hint:                                        I/O Historie nach Files aus DBA_Hist_FileStatxs

  menu_sga_pga_cache_advice_caption:                        DB-Cache Advice historisch
  menu_sga_pga_cache_advice_hint:                           Historische Anlistung der "was wäre wenn"-Analyse bei Veränderung der Größe des DB-Cache
  menu_sga_pga_cache_usage_caption:                         DB-Cache-Nutzung
  menu_sga_pga_cache_usage_hint:                            Aktueller Inhalt des DB-Cache
  menu_sga_pga_compare_execution_plans:                     Vergleich der Execution-Pläne zweier Cursoren in SGA
  menu_sga_pga_sga_components_caption:                      SGA-Komponenten
  menu_sga_pga_sga_components_hint:                         Anlistung der Komponenten der aktuellen SGA
  menu_sga_pga_day_compare_caption:                         SQL-Area Tagesvergleich
  menu_sga_pga_day_compare_hint:                            Vergleich der SQL-statements zweier Tage
  menu_sga_pga_object_by_file_and_block_caption:            Objekt nach File und Block
  menu_sga_pga_object_by_file_and_block_hint:               Ermittlung des Objektnamens zu File- und Block-Nummer
  menu_sga_pga_object_usage_caption:                        Object-Nutzung durch SQL
  menu_sga_pga_object_usage_current_hint:                   Nutzung gesuchter Objekte im Explain Plan aktuell in SGA befindlicher SQLs
  menu_sga_pga_object_usage_historic_hint:                  Nutzung gesuchter Objekte im Explain Plan historischer SQLs
  menu_sga_pga_pga_statistics_caption:                      PGA-Statistik
  menu_sga_pga_pga_statistics_current_hint:                 Anzeige aktuelle PGA-Auslastung
  menu_sga_pga_pga_statistics_historic_hint:                Anzeige historische PGA-Auslastung
  menu_sga_pga_result_cache_current_hint:                   Anzeige aktuelle Auslastung des Result-Cache
  menu_sga_pga_sqlarea_current_sqlid_caption:               Aktuell (SQL-ID)
  menu_sga_pga_sqlarea_current_sqlid_hint:                  Auswertung aktuelle SQLs aus SGA auf Ebene SQL-ID (Kumuliert über Child-Cursoren)
  menu_sga_pga_sqlarea_current_sqlid_childno_caption:       Aktuell (SQL-ID / Child-Nr.)
  menu_sga_pga_sqlarea_current_sqlid_childno_hint:          Auswertung aktuelle SQLs aus SGA auf Ebene SQL_ID, Child-Nr.
  menu_sga_pga_sqlarea_historic_hint:                       Auswertung historische SQLs aus DBA_Hist_SQLStat

  menu_storage_datafile_caption:                            Datafile-Nutzung
  menu_storage_datafile_hint:                               Anlistung der Datafiles der DB
  menu_storage_matview_hint:                                Auswertung Strukturen von Materialized Views und MV-Logs
  menu_storage_storage_summary_caption:                     Plattenspeicher-Nutzung
  menu_storage_storage_summary_hint:                        Übersicht über Plattenspeicher-/Tablespace-Nutzung
  menu_storage_table_dependency_caption:                    Table-Abhängigkeiten
  menu_storage_table_dependency_hint:                       Mittelbare und unmittelbare referentielle Abhängigkeiten von Tabellen
  menu_storage_temp_usage_historic_hint:                    Historische Auslastung des TEMP-Tablespace

  menu_storage_undo_history_caption:                        UNDO-Nutzung historisch
  menu_storage_undo_history_hint:                           Historische Nutzung von UNDO-Space
  menu_storage_undo_usage_caption:                          UNDO Segmente
  menu_storage_undo_usage_hint:                             Aktuelle Nutzung von UNDO-Space nach Segmenten

  menu_wait_caption:                                        Analysen / Statistiken
  menu_wait_db_file_sequential_read_hint: |-
    Aktuelle Wait-Auslöser 'db file sequential read' (Vorsicht: Langsam auf großen Systemen)
  menu_wait_enqueue_caption:                                Enqueue-Statistiken
  menu_wait_enqueue_historic_hint:                          Aufbereitete historische Informationen aus DBA_Hist_Enqueue_Stat
  menu_wait_enqueue_rac_hint:                               Dem RAC-Lock-Manager bekannte Blocking Enqueue Locks
  menu_wait_gc_historic_hint:                               Auswertung Global Cache-Aktivität
  menu_wait_latch_caption:                                  Latch-Statistiken
  menu_wait_latch_cbc_hint:                                 Aktuelle Auslöser für Cache Buffer Chains-Latch-Waits
  menu_wait_latch_statistics_historic_hint:                 Aufbereitete historische Informationen aus DBA_Hist_Latch
  menu_wait_mutex_caption:                                  Mutex-Statistiken
  menu_wait_mutex_historic_hint:                            Aufbereitete historische Informationen aus GV$Mutex_Sleep_History seit Start der Instance
  menu_wait_resource_limits_historic_caption:               Ressourcen-Limits historisch
  menu_wait_resource_limits_historic_hint:                  Historische Nutzung und Limits von Ressourcen aus DBA_Hist_Resource_Limit
  menu_wait_segment_current_hint:                           Aktuelle Waits nach DB-Objekten
  menu_wait_segment_historic_hint:                          Historisierte Waits nach DB-Objekten
  menu_wait_session_cpu_hint:                               Historische CPU-Usage und DB-Time aus DBA_Hist_Active_Sess_History
  menu_wait_session_current_hint:                           Alle aktuelle Session-Waits
  menu_wait_session_historic_hint:                          Aufbereitete Active-Session-Informationen aus DBA_Hist_Active_Sess_History
  menu_wait_special_caption:                                Spezielle Event-Auswertungen
  menu_wait_system_caption:                                 System-Statistiken
  menu_wait_system_events_current_hint:                     Aktuelle System-Events
  menu_wait_system_events_historic_hint:                    Historisierte System-Events
  menu_wait_sysmetric_caption:                              System-Metric
  menu_wait_sysmetric_historic_hint:                        Historisierte System-Metric aus DBA_Hist_Sysmetric_History
  menu_wait_system_statistics_historic_hint:                Historisierte System-Statistik


  menu_addition_caption:                                    Spez. Erweiterungen
  menu_addition_dragnet_caption:                            Rasterfahndung
  menu_addition_dragnet_hint:                               Rasterfahndung nach Performance-Bottlenecks

  menu_env_index_hint:                                      Start der Applikation ohne Anmeldung an Datenbank
  menu_env_set_database_hint:                               Start der Applikation nach Anmeldung an Datenbank
  menu_help_content_caption:                                Aktueller Inhalt
  menu_help_content_hint:                                   Hilfe zu aktuellem Inhalt
  menu_help_overview_caption:                               Überblick
  menu_help_overview_hint:                                  Überblick über Hilfe-Themen
  menu_help_contact_caption:                                Kontakt
  menu_help_contact_hint:                                   Kontakt zum Hersteller
  menu_help_version_history_caption:                        Versions-Historie
  menu_help_version_history_hint:                           Entwicklungs-Historie von Funktionen und Versionen

  show_mutex_statistics_historic_blocker_hint:              Mutex-Sleep-Historie Gruppiert nach Blocker-Sessions
  show_mutex_statistics_historic_caption:                   Mutex-Statistiken aus GV$Mutex_Sleep_History (seit Instance-Start)
  show_mutex_statistics_historic_timeline_caption:          Zeitliche Historie
  show_mutex_statistics_historic_timeline_hint:             Mutex-Sleep-Historie zeitlich gruppiert
  show_mutex_statistics_historic_waiter_hint:               Mutex-Sleep-Historie Gruppiert nach Waiter-Sessions

  storage_tablespace_usage_header_caption:                  Storage-Objekte für Datenbank
  storage_tablespace_usage_schemas_mb_hint:                 Genutzter Platz in MB für Segment-Typ
  storage_tablespace_usage_schemas_link_hint:               Anzeige der Objekte des Schemas
  storage_tablespace_usage_tablespaces_link_hint:           Anzeige der Objekte des Tablespaces

